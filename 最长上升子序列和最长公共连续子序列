//最长上升子序列——动态规划
//dp[i]代表以a[i]为结尾的最长上升子序列的长度
//递归公式：dp[i]=max(dp[i],dp[i+1])(0<=j<i,a[j]<a[i])
//边界处理：dp[i]=1(0<=j<n)
//在0-j范围内，找到a[i]前面比a[i]小的元素，取其中的最大dp值+1，就是dp[i]的值
int LIS()
{
	int ans = 1;
	for (int i = 1;i <= n;i++)//枚举子序列的终点
	{
		dp[i] = 1;//初始为1，长度最短为自身
		for (int j = 1;j < i;j++)//从头向终点检查每一个元素
		{
			if (a[i] > a[j])
			{
				dp[i] = max(dp[i], dp[j] + 1);//状态转移
			}
		}
		ans = max(ans, dp[i]);//比较每一个dp[i]最大值为答案
	}
	return ans;
}
//基于贪心+二分搜索的最长上升子序列
//算法思想：对于一个上升子序列，当前最后一个元素越小，越有利于添加新的元素，这样L长度自然越长
//dp[i]存放当前上升子序列
//代码
int pos = 0;//记录当前dp最后一个下标
dp[0] = a[0];//dp[0]显然等于a[0]
for (int i = 1;i < n;i++)
{
	if (a[i] > dp[pos])//若a[i]大于dp数组的最大值，则直接添加
	{
		dp[++pos] = a[i];
	}
	else//否则找到dp中第一个大于等于a[i]的位置，用a[i]替换掉
	{
		dp[lower_bound(dp, dp + pos + 1, a[i]) - dp] = a[i];//二分查找   lower_bound是库函数 通常应该自己写swap（交换）函数
	}
}

//最长连续公共子序列递归公式就是去掉最后一行的公共子序列的递归公式：c[i][j]那个
