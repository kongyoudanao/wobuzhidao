//
//最优装载方案
//将第一艘船尽可能装满，将剩余装到第二艘
//将第一艘船装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最大

//解空间：子集树
//可行性约束函数左分支：  Wt*Xt<=C1（选的重量小于等于第一艘船的载重量）
//上界函数（右分支）：当前载重量CW+剩余集装箱的量R<=当前最优载重量bestw

void Backtrack(int i)
{
	//搜索第i层节点   i初始值就是赋值1
	if (i > n)//到达叶子节点
	{
		//更新最优解bestw，且返回
	}
	r -= w[i];//r的初值为全部集装箱的重量之和
	if (cw + w[i] <= c)//搜索左子树
	{
		x[i] = 1;
		cw += w[i];
		Backtrack(i + 1);
		cw -= w[i];
	}
	if (cw + r > bestw)
	{
		x[i] = 0;//搜索右子树
		Backtrack(t + 1);
	}
	r += w[i]; 
}
